\set HISTCONTROL ignoreboth
\set HISTSIZE 5000

\pset null -NULL-
\pset pager off
\timing

\set trashindexes '( select s.schemaname as sch, s.relname as rel, s.indexrelname as idx, s.idx_scan as scans, pg_size_pretty(pg_relation_size(s.relid)) as ts, pg_size_pretty(pg_relation_size(s.indexrelid)) as "is" from pg_stat_user_indexes s join pg_index i on i.indexrelid=s.indexrelid left join pg_constraint c on i.indrelid=c.conrelid and array_to_string(i.indkey, '' '') = array_to_string(c.conkey, '' '') where i.indisunique is false and pg_relation_size(s.relid) > 1000000 and s.idx_scan < 100000 and c.confrelid is null order by s.idx_scan asc, pg_relation_size(s.relid) desc )'
\set missingindexes '( select src_table, dst_table, fk_name, pg_size_pretty(s_size) as s_size, pg_size_pretty(d_size) as d_size, d from ( select distinct on (1,2,3,4,5) textin(regclassout(c.conrelid)) as src_table, textin(regclassout(c.confrelid)) as dst_table, c.conname as fk_name, pg_relation_size(c.conrelid) as s_size, pg_relation_size(c.confrelid) as d_size, array_upper(di.indkey::int[], 1) + 1 - array_upper(c.conkey::int[], 1) as d from pg_constraint c left join pg_index di on di.indrelid = c.conrelid and array_to_string(di.indkey, '' '') ~ (''^'' || array_to_string(c.conkey, '' '') || ''( |$)'') join pg_stat_user_tables st on st.relid = c.conrelid where c.contype = ''f'' order by 1,2,3,4,5,6 asc) mfk where mfk.d is distinct from 0 and mfk.s_size > 1000000 order by mfk.s_size desc, mfk.d desc )'

\set rtsize '(select table_schema, table_name, pg_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) as size, pg_total_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) as total_size  from information_schema.tables where table_type = \'BASE TABLE\' and table_schema not in (\'information_schema\', \'pg_catalog\') order by pg_relation_size( quote_ident( table_schema ) || \'.\' || quote_ident( table_name ) ) desc, table_schema, table_name)'
\set tsize '(select table_schema, table_name, pg_size_pretty(size) as size, pg_size_pretty(total_size) as total_size from (:rtsize) x order by x.size desc, x.total_size desc, table_schema, table_name)'

\set ridxsize '(select s.relname as table_name, s.indexrelname as idx_name, pg_relation_size(s.indexrelid) as idx_size from pg_stat_user_indexes s join pg_index i on i.indexrelid=s.indexrelid order by table_name, idx_name)'
\set idxsize '(select table_name, idx_name, pg_size_pretty(idx_size) as idx_size from (:ridxsize) x)'

\set expan 'explain (analyze on, buffers on, verbose on)'
\set exp 'explain (verbose on)'

\set count '(select datname, usename, application_name, count(*) from pg_stat_activity group by datname, usename, application_name union (select \'all_databases\' as datname, \'total\' as usename, \'\' as application_name, count(*) from pg_stat_activity)  order by datname, usename, application_name)'

\set active '(select * from pg_stat_activity where state <> \'idle\' and pid <> pg_backend_pid() order by query_start desc)'
\set active90 '(select * from pg_stat_activity where current_query <> \'<IDLE>\' and procpid <> pg_backend_pid() order by query_start desc)'

\set count '(select datname, usename, application_name, count(*) from pg_stat_activity group by datname, usename, application_name union (select \'all_databases\' as datname, \'total\' as usename, \'\' as application_name, count(*) from pg_stat_activity)  order by datname, usename, application_name)'
